<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title xmlns:d="http://docbook.org/ns/docbook">Bootique Documentation</title><link rel="stylesheet" type="text/css" href="css/doc.css"><meta xmlns:d="http://docbook.org/ns/docbook" name="keywords" content="Bootique Framework Documentation version 0 "><meta xmlns:d="http://docbook.org/ns/docbook" name="description" content="Bootique: A Minimally Opinionated Framework for Runnable Java Apps - Documentation version 0"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-73654436-1', 'auto');
  ga('send', 'pageview');
        </script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="Bootique Documentation"><div class="titlepage"><div><div><h1 class="title"><a name="linkrest-guide"></a>Bootique Documentation</h1></div><div><p class="copyright">Copyright &copy; 2016 National Hockey League, ObjectStyle LLC and individual authors</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="part"><a href="#overview">I. Overview</a></span></dt><dd><dl><dt><span class="chapter"><a href="#overview-what-is-bootique">1. What is Bootique</a></span></dt><dt><span class="chapter"><a href="#d50e42">2. Java Version</a></span></dt><dt><span class="chapter"><a href="#d50e47">3. Build System</a></span></dt><dt><span class="chapter"><a href="#d50e55">4. Programming Skills</a></span></dt></dl></dd><dt><span class="part"><a href="#programming">II. Programming</a></span></dt><dd><dl><dt><span class="chapter"><a href="#programming-modules">5. Modules</a></span></dt><dt><span class="chapter"><a href="#programming-module-providers">6. Modules Auto-Loading</a></span></dt><dt><span class="chapter"><a href="#programming-configuration">7. Reading Configuration and Configurable Factories</a></span></dt><dd><dl><dt><span class="section"><a href="#d50e184">Polymorphic Configuration Objects</a></span></dt></dl></dd><dt><span class="chapter"><a href="#programming-using-modules">8. Using Modules</a></span></dt><dd><dl><dt><span class="section"><a href="#d50e243">Injecting Other Module's Services</a></span></dt><dt><span class="section"><a href="#d50e258">Contributing to Other Modules</a></span></dt></dl></dd><dt><span class="chapter"><a href="#programming-application-module">9. Application as a Module</a></span></dt><dt><span class="chapter"><a href="#d50e305">10. Commands and Options</a></span></dt><dt><span class="chapter"><a href="#d50e312">11. Logging</a></span></dt></dl></dd><dt><span class="part"><a href="#testing">III. Testing</a></span></dt><dd><dl><dt><span class="chapter"><a href="#d50e320">12. Writing Unit Tests</a></span></dt></dl></dd><dt><span class="part"><a href="#assembly-deployment">IV. Assembly and Deployment</a></span></dt><dd><dl><dt><span class="chapter"><a href="#programming-runnable-jar">13. Runnable Jar</a></span></dt><dt><span class="chapter"><a href="#deployment-tracing">14. Tracing Bootique Startup</a></span></dt></dl></dd></dl></div><div class="part" title="Part&nbsp;I.&nbsp;Overview"><div class="titlepage"><div><div><h1 class="title"><a name="overview"></a>Part&nbsp;I.&nbsp;Overview</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#overview-what-is-bootique">1. What is Bootique</a></span></dt><dt><span class="chapter"><a href="#d50e42">2. Java Version</a></span></dt><dt><span class="chapter"><a href="#d50e47">3. Build System</a></span></dt><dt><span class="chapter"><a href="#d50e55">4. Programming Skills</a></span></dt></dl></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;What is Bootique"><div class="titlepage"><div><div><h2 class="title"><a name="overview-what-is-bootique"></a>Chapter&nbsp;1.&nbsp;What is Bootique</h2></div></div></div><p>Bootique is a minimally opinionated technology for building container-less runnable
            Java applications. No JavaEE container required to run your app! It is an ideal platform
            for <span class="emphasis"><em><a class="link" href="http://martinfowler.com/articles/microservices.html" target="_top">microservices</a></em></span>, as it allows you to create a fully functional
            app with minimal-to-no setup. Though it is not limited to a specific kind of app (or the
            "micro" size) and can be used for REST services, webapps, runnable jobs, DB migrations,
            JavaFX GUI apps to mention a few examples.</p><p>Unlike traditional container-based apps, Bootique allows you to control your
                <code class="code">main()</code> method and create Java apps that behave like simple executable
            commands that can be run with
            Java:</p><pre class="programlisting">java -jar my.jar [arguments]</pre><p>Each Bootique app can be started with a YAML configuration loaded from a file or from
            a remote URL. Among other benefits, such configuration approach ideally suits cloud
            deployment environments.</p><p>Bootique was inspired by two similar products - <a class="link" href="http://www.dropwizard.io/" target="_top">Dropwizard</a> and <a class="link" href="http://projects.spring.io/spring-boot/" target="_top">SpringBoot</a>, however its
            focus is different. Bootique favors modularity and clean pluggable architecture.
            Bootique is built on top of <a class="link" href="https://github.com/google/guice" target="_top">Google
                Guice</a> dependency injection (DI) container, which provides the core of its
            modularity mechanism. This means that pretty much anything in Bootique can be
            customized/overridden to your liking.</p></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;Java Version"><div class="titlepage"><div><div><h2 class="title"><a name="d50e42"></a>Chapter&nbsp;2.&nbsp;Java Version</h2></div></div></div><p>Java 8 or newer is required. </p></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;Build System"><div class="titlepage"><div><div><h2 class="title"><a name="d50e47"></a>Chapter&nbsp;3.&nbsp;Build System</h2></div></div></div><p>Bootique apps can be built using any Java build system (Ant, Maven, Gradle, etc).
                Examples in the documentation are based on Maven and
                <code class="code">maven-shade-plugin</code>. While this is not strictly a requirement, Bootique
                apps are usually packaged into "fat" runnable jars and don't have any external
                dependencies beyond the JRE.</p></div><div class="chapter" title="Chapter&nbsp;4.&nbsp;Programming Skills"><div class="titlepage"><div><div><h2 class="title"><a name="d50e55"></a>Chapter&nbsp;4.&nbsp;Programming Skills</h2></div></div></div><p>Everyting you know about Java programming will be applicable when working with
            Bootique. You may need to "unlearn" some of the practices related to JEE configuration
            and container deployment though. </p><p>Integration between various parts of a Bootique app is done via <a class="link" href="https://github.com/google/guice" target="_top">Google Guice</a>. In most cases
            Bootique API would steer you towards idiomatic approach to integration, so deep
            knowledge of Guice is not required. Though it wouldn't hurt to understand a few main
            concepts: modules, bindings, <a class="link" href="https://github.com/google/guice/wiki/Multibindings" target="_top">multibindings</a>, <a class="link" href="http://google.github.io/guice/api-docs/latest/javadoc/index.html?com/google/inject/util/Modules.html" target="_top">overrides</a>.</p><p>Java <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" target="_top">ServiceLoader</a> facility is another important part of Bootique, and
                probably one other thing that you shouldn't worry too much about initially.</p></div></div><div class="part" title="Part&nbsp;II.&nbsp;Programming"><div class="titlepage"><div><div><h1 class="title"><a name="programming"></a>Part&nbsp;II.&nbsp;Programming</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#programming-modules">5. Modules</a></span></dt><dt><span class="chapter"><a href="#programming-module-providers">6. Modules Auto-Loading</a></span></dt><dt><span class="chapter"><a href="#programming-configuration">7. Reading Configuration and Configurable Factories</a></span></dt><dd><dl><dt><span class="section"><a href="#d50e184">Polymorphic Configuration Objects</a></span></dt></dl></dd><dt><span class="chapter"><a href="#programming-using-modules">8. Using Modules</a></span></dt><dd><dl><dt><span class="section"><a href="#d50e243">Injecting Other Module's Services</a></span></dt><dt><span class="section"><a href="#d50e258">Contributing to Other Modules</a></span></dt></dl></dd><dt><span class="chapter"><a href="#programming-application-module">9. Application as a Module</a></span></dt><dt><span class="chapter"><a href="#d50e305">10. Commands and Options</a></span></dt><dt><span class="chapter"><a href="#d50e312">11. Logging</a></span></dt></dl></div><div class="chapter" title="Chapter&nbsp;5.&nbsp;Modules"><div class="titlepage"><div><div><h2 class="title"><a name="programming-modules"></a>Chapter&nbsp;5.&nbsp;Modules</h2></div></div></div><p>Bootique apps are made of "modules". The framework simply locates all available
            modules, loads them in the DI environment, parses the command line, and then transfers
            control to a Command (that can originate from any of the modules) that matched the user
            choice. There's a growing list of modules created by Bootique development team. And you
            can easily write your own. In fact, programming in Bootique is primarily about writing
            Modules. </p><p>A module is a Java library that contains some code. What makes it a module is a
            special Java class that implements <a class="link" href="https://google.github.io/guice/api-docs/latest/javadoc/index.html?com/google/inject/Module.html" target="_top">Guice Module interface</a>. This class defines what "services" or other types of
            objects the module provides (in other words what will be injectable by the module
            users). This is done in a form of "bindings", i.e. associations between publicly visible
            injectable service interfaces and specific
            implementations:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> MyModule <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">implements</span> Module {
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-annotation">@Override</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</span> configure(Binder binder) {
		binder.bind(MyService.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>).to(MyServiceImpl.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>);
	}
}</pre><p>There are other flavors of bindings in Guice. Please refer to <a class="link" href="https://github.com/google/guice/wiki/Motivation" target="_top">Guice
                documentation</a> for details. One important form extensively used in Bootique is
                <a class="link" href="https://github.com/google/guice/wiki/Multibindings" target="_top">Multibinding</a>.</p></div><div class="chapter" title="Chapter&nbsp;6.&nbsp;Modules Auto-Loading"><div class="titlepage"><div><div><h2 class="title"><a name="programming-module-providers"></a>Chapter&nbsp;6.&nbsp;Modules Auto-Loading</h2></div></div></div><p>Modules can be automatically loaded via <code class="code">Bootique.autoLoadModules()</code> as
            long as they are included in your aplication dependencies. Auto-loading depends on the
            Java <a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" target="_top">ServiceLoader mechanism</a>. To ensure your modules can be auto-loaded do two
            things. First implement <code class="code">com.nhl.bootique.BQModuleProvider</code> interface
            specific to your
            module:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> MyModuleProvider <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">implements</span> BQModuleProvider {
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-annotation">@Override</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> Module module() {
		<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">return</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</span> MyModule();
	}
}</pre><p>After
            then create a file <code class="code">META-INF/services/com.nhl.bootique.BQModuleProvider</code> with
            the only line being the name of your BQModuleProvider implementor. E.g.:</p><pre class="programlisting">com.foo.MyModuleProvider</pre><p><code class="code">BQModuleProvider</code> has two more methods that you can optionally
            implement to help Bootique to make sense of the module being
            loaded:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> MyModuleProvider <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">implements</span> BQModuleProvider {
	...
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// provides human-readable name of the module</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-annotation">@Override</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> String name() {
		<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">return</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-string">"CustomName"</span>;
	}
	
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// a collection of modules whose services are overridden by this module</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-annotation">@Override</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> Collection&lt;Class&lt;? <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">extends</span> Module&gt;&gt; overrides() {
		<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">return</span> Collections.singleton(BQCoreModule.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>);
	}
}</pre><p>If  in your Module you are planning to redefine any services from the upstream
            modules, specify those upstream modules in the <code class="code">overrides()</code> collection. </p></div><div class="chapter" title="Chapter&nbsp;7.&nbsp;Reading Configuration and Configurable Factories"><div class="titlepage"><div><div><h2 class="title"><a name="programming-configuration"></a>Chapter&nbsp;7.&nbsp;Reading Configuration and Configurable Factories</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d50e184">Polymorphic Configuration Objects</a></span></dt></dl></div><p>As mentioned above, a Bootique app can be started with a YAML configuration file. Here
            is a simple example of such
            file:</p><pre class="programlisting">log:
  level: warn
  appenders:
    - type: file
      logFormat: <span xmlns="http://www.w3.org/1999/xhtml" class="hl-string">'%c{20}: %m%n'</span>
      file: target/logback/debug.log

jetty:
  context: /myapp
  connector:
    port: <span xmlns="http://www.w3.org/1999/xhtml" class="hl-number">12009</span>
</pre><p>While this is not strictly required, as a rule the top-level keys in the file belong
            to configuration objects of individual modules. In the example above "log" subtree
            configures <code class="code">bootique-logback</code> module, while "jetty" subtree configures
                <code class="code">bootique-jetty-module</code>. For standard modules, refer to module-specific
            documentation on the structure of the supported configuration. Here we'll discuss how to
            build your own configuration-aware module.</p><p>Bootique allows the Module to read its specific configuration subree as an object of
            the type defined in the Module. Very often such an object as written as a factory that
            contains a bunch of setters for the configuration properties, and a factory method to
            produce some service that a Module is interested in based on this configuration. Here is
            an example
            factory:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> MyFactory {

	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">private</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">int</span> intProperty;
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">private</span> String stringProperty;

	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</span> setIntProperty(<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">int</span> i) {
		<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">this</span>.intProperty = i;
	}

	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</span> setStringProperty(String s) {
		<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">this</span>.stringProperty = s;
	}

	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// factory method</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> MyService createMyService(SomeOtherService soService) {
		<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">return</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</span> MyServiceImpl(soService, intProperty, stringProperty);
	}
}</pre><p>The factory contains configuration property declarations, as well as public setters
            for these properties (you can create the getters if you want as well. While this is not
            strictly required, it may be useful. E.g. for unit tests). Now let's take a look at the
            Module
            class:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> MyModule <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">extends</span> ConfigModule {
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-annotation">@Provides</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> MyService createMyService(
             ConfigurationFactory configFactory, 
             SomeOtherService soService) {

		<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">return</span> configFactory
                 .config(MyFactory.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>, configPrefix)
                 .createMySerice(soService);
	}
}</pre><p>And now a sample configuration that will work with our
            module:</p><pre class="programlisting">my:
  intProperty: 55
  stringProperty: 'Hello, world!'</pre><p>A few points to note here: </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Calling our module "MyModule" and extending from <code class="code">ConfigModule</code>
                        gives it access to the protected "configPrefix" instance variable that is
                        initialized to the value of "my" (the naming convention here is to use the
                        Module simple class name without the "Module" suffix and converted to
                        lowercase).</p></li><li class="listitem"><p><code class="code">@Provides</code> annotation is a Guice way of marking a Module
                        method as a "provider" for a certain type of injectable service. All its
                        parameters are themselves injectable objects. </p></li><li class="listitem"><p><code class="code">ConfigurationFactory</code> is the class used to bind a subtree in
                        the app YAML configuration to a given Java object (in our case - MyFactory).
                        The structure of MyFactory is very simple here, but can be as complex as
                        needed, containing nested objects, arrays, maps, etc. Internally Bootique
                        uses <a class="link" href="http://wiki.fasterxml.com/JacksonHome" target="_top">Jackson
                            framework</a> to bind YAML to a Java class, so all the features of
                        Jackson can be used to craft configuration.</p></li></ul></div><p>
        </p><div class="section" title="Polymorphic Configuration Objects"><div class="titlepage"><div><div><h2 class="title"><a name="d50e184"></a>Polymorphic Configuration Objects</h2></div></div></div><p>A powerful feature of Jackson is the ability to dynamically create subclasses of
                the configuration objects. Bootique takes full advantage of this. E.g. imagine a
                logging module that needs "appenders" to output its log messages (file appender,
                console appender, syslog appender, etc.). The framework might not be aware of all
                possible appenders its users might come up with in the future. Yet it still wants to
                have the ability to instantiate any of them, based solely on the data coming from
                YAML. Moreover each appender will have its own set of incompatble configuration
                properties. In fact this is exactly the situation with <code class="code">bootique-logback</code>
                module. </p><p>Here is how you ensure that such a polimorphic configuration is possible. Let's
                start with a simple class hierarchy and a factory that contains a variable of the
                supertype that we'd like to init to a concrete subclass in
                runtime:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">abstract</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> SuperType {
...
}

<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> ConcreteType1 <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">extends</span> SuperType {
...
}

<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> ConcreteType2 <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">extends</span> SuperType {
...	
}

<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> MyFactory {

	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// can be a class or an interface</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">private</span> SuperType subconfig;
	

	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</span> setSubconfig(SuperType s) {
		<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">this</span>.subconfig = s;
	}	
...
}</pre><p>To make polimorphism work, we need to provide some instructions to Jackson. First
                we need to annotate the supertype and
                subtypes:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-annotation">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, 
     property = "type", 
     defaultImpl = ConcreteType1.class)</span>
<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">abstract</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> SuperType {

}

<span xmlns="http://www.w3.org/1999/xhtml" class="hl-annotation">@JsonTypeName("type1")</span>
<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> ConcreteType1 <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">extends</span> SuperType {

}

<span xmlns="http://www.w3.org/1999/xhtml" class="hl-annotation">@JsonTypeName("type2")</span>
<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> ConcreteType2 <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">extends</span> SuperType {
	
}</pre><p>After that we need to create a service provider file called
                    <code class="code">META-INF/service/com.nhl.bootique.config.PolymorphicConfiguration</code>
                where all the types participating in the hierarchy are listed (including the
                supertype):</p><pre class="programlisting">com.foo.SuperType
com.foo.ConcreteType1
com.foo.ConcreteType2</pre><p>This should be enough to work with configuration like
                this:</p><pre class="programlisting">my:
  subconfig:
    type: type2
    someVar: someVal</pre><p>Or this (here type is implicitly assumed to be "type1", see the "defaultImpl" in
                the <code class="code">@JsonTypeInfo</code> annotation
                above:</p><pre class="programlisting">my:
  subconfig:
    someOtherVar: someOtherVal</pre><p>If another module decides to create yet another subclass of SuperType, it will
                need to create its own
                    <code class="code">META-INF/service/com.nhl.bootique.config.PolymorphicConfiguration</code>
                file that metions the new subclass.</p></div></div><div class="chapter" title="Chapter&nbsp;8.&nbsp;Using Modules"><div class="titlepage"><div><div><h2 class="title"><a name="programming-using-modules"></a>Chapter&nbsp;8.&nbsp;Using Modules</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d50e243">Injecting Other Module's Services</a></span></dt><dt><span class="section"><a href="#d50e258">Contributing to Other Modules</a></span></dt></dl></div><p>Modules can use other "upstream" modules in a few ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>"Import": a downstream module uses another module as a library, ignoring
                        its injectable services.</p></li><li class="listitem"><p>"Use" : downstream module's classes inject classes from an upstream
                        module.</p></li><li class="listitem"><p>"Contribute": downstream module injects objects to collections and maps
                        defined in upstream modules.</p></li></ul></div><p>Import case is trivial, so we'll concentrate on the two remaining scenarios. We
            will use <a class="link" href="https://github.com/nhl/bootique/blob/master/bootique/src/main/java/com/nhl/bootique/BQCoreModule.java" target="_top">BQCoreModule</a> as an example of an upstream module, as it is available in all
            apps.</p><div class="section" title="Injecting Other Module's Services"><div class="titlepage"><div><div><h2 class="title"><a name="d50e243"></a>Injecting Other Module's Services</h2></div></div></div><p>BQCoreModule provides a number of objects and services that can be accessed via
                injection and used by your code.
                E.g.:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> MyService {

	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-annotation">@Args</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-annotation">@Inject</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">private</span> String[] args;

	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> String getArgsString() {
		<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">return</span> Arrays.asList(getArgs()).stream().collect(joining(<span xmlns="http://www.w3.org/1999/xhtml" class="hl-string">" "</span>));
	}
}</pre><p>In this example we injected command line arguments that were used to start the
                app. Note that since there can potentially be more than one <code class="code">String[]</code> in
                a DI container, Bootique <code class="code">@Args</code> annotation is used to uniquely identify
                the array that we want here.</p></div><div class="section" title="Contributing to Other Modules"><div class="titlepage"><div><div><h2 class="title"><a name="d50e258"></a>Contributing to Other Modules</h2></div></div></div><p>Guice supports <a class="link" href="https://github.com/google/guice/wiki/Multibindings" target="_top">multibindings</a>, intended to <span class="emphasis"><em>contribute</em></span> objects
                defined in a downstream module to collections/maps used by services in upstream
                modules. E.g. the following code makes <code class="code">MyCommand</code> available in the app
                set of
                commands:</p><pre class="programlisting">public class MyModule implements Module {

	@Override
	public void configure(Binder binder) {
		BQCoreModule.contributeCommands(binder)
			.addBinding()
			.to(MyCommand.class);
	}
}</pre><p>Here we obtained a Multibinder instance via a static method on BQCoreModule. Most
                standard modules define such helper methods for every collection/map that should be
                populated by module users. This is a pattern you might want to follow in your own modules.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Commands can be alternatively contributed using a special
                            <code class="code">Commands</code> module builder described below, which is a
                        shortcut for the code above.</p></div></div></div><div class="chapter" title="Chapter&nbsp;9.&nbsp;Application as a Module"><div class="titlepage"><div><div><h2 class="title"><a name="programming-application-module"></a>Chapter&nbsp;9.&nbsp;Application as a Module</h2></div></div></div><p>The class that contains the <code class="code">"main()"</code> method is informally called
                "application". Bootique does not impose any particular requirements on this class.
                You decide what to put in it. It can be limited to just <code class="code">"main()"</code>,
                turned into a REST resource, etc. </p><p>We recommend wrapping all your custom code in Guice modules. Then you can view
            your apps as collections of modules. In this scenario, it makes the most sense to write
            your application class as either just a launcher with the static <code class="code">"main()"</code>
            method or in addition to that turn it into a Module as well. After all Bootique app is
            just a collection of Modules, and it is but logical that your Application represents
            that one final Module to rule them
            all:</p><pre class="programlisting">public class Application implements Module {

   public static void main(String[] args) {
      Bootique.app(args).module(Application.class).autoLoadModules().run();
   }

   public void configure(Binder binder) {
      // load app-specific services; redefine standard ones
   }
}</pre><p>You may also implement a separate BQModuleProvider for the Application module.
            Then <code class="code">autoLoadModules()</code> will discover it just like any other Module, and
            there won't be a need to add Application module explicitly.</p></div><div class="chapter" title="Chapter&nbsp;10.&nbsp;Commands and Options"><div class="titlepage"><div><div><h2 class="title"><a name="d50e305"></a>Chapter&nbsp;10.&nbsp;Commands and Options</h2></div></div></div><p>Bootique runtime contains a set of commands. Bootique derives a command name to
            execute from the command line arguments. The initial set of available commands is a
            combination of commands coming from Bootique core framework and any modules currently in
            effect in the app.</p><p>TODO</p></div><div class="chapter" title="Chapter&nbsp;11.&nbsp;Logging"><div class="titlepage"><div><div><h2 class="title"><a name="d50e312"></a>Chapter&nbsp;11.&nbsp;Logging</h2></div></div></div><p>TODO</p></div></div><div class="part" title="Part&nbsp;III.&nbsp;Testing"><div class="titlepage"><div><div><h1 class="title"><a name="testing"></a>Part&nbsp;III.&nbsp;Testing</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#d50e320">12. Writing Unit Tests</a></span></dt></dl></div><div class="chapter" title="Chapter&nbsp;12.&nbsp;Writing Unit Tests"><div class="titlepage"><div><div><h2 class="title"><a name="d50e320"></a>Chapter&nbsp;12.&nbsp;Writing Unit Tests</h2></div></div></div><p>TODO</p></div></div><div class="part" title="Part&nbsp;IV.&nbsp;Assembly and Deployment"><div class="titlepage"><div><div><h1 class="title"><a name="assembly-deployment"></a>Part&nbsp;IV.&nbsp;Assembly and Deployment</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#programming-runnable-jar">13. Runnable Jar</a></span></dt><dt><span class="chapter"><a href="#deployment-tracing">14. Tracing Bootique Startup</a></span></dt></dl></div><div class="chapter" title="Chapter&nbsp;13.&nbsp;Runnable Jar"><div class="titlepage"><div><div><h2 class="title"><a name="programming-runnable-jar"></a>Chapter&nbsp;13.&nbsp;Runnable Jar</h2></div></div></div><p>TODO</p></div><div class="chapter" title="Chapter&nbsp;14.&nbsp;Tracing Bootique Startup"><div class="titlepage"><div><div><h2 class="title"><a name="deployment-tracing"></a>Chapter&nbsp;14.&nbsp;Tracing Bootique Startup</h2></div></div></div><p>To see what modules are loaded and to trace other events that happen on startup, run
            your jar with <code class="code">-Dbq.trace</code> option. E.g.:</p><pre class="programlisting">java -Dbq.trace -jar target/myapp-1.0.jar --server</pre><p>You may see an output like this:</p><pre class="programlisting">Skipping module 'JerseyModule' provided by 'JerseyModuleProvider' (already provided by 'Bootique')...
Adding module 'BQCoreModule' provided by 'Bootique'...
Adding module 'JerseyModule' provided by 'Bootique'...
Adding module 'JettyModule' provided by 'JettyModuleProvider'...
Adding module 'LogbackModule' provided by 'LogbackModuleProvider'...</pre></div></div></div></body></html>