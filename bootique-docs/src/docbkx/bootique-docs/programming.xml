<?xml version="1.0" encoding="UTF-8"?>
<part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0" xml:id="programming">
    <title>Programming</title>

    <chapter xml:id="programming-modules">
            <title>Modules</title>
            <para>Bootique apps are made of "modules". The framework simply locates all available
            modules, loads them in the DI environment, parses the command line, and then transfers
            control to a Command (that can originate from any of the modules) that matched the user
            choice. There's a growing list of modules created by Bootique development team. And you
            can easily write your own. In fact, programming in Bootique is primarily about writing
            Modules. </para>
            <para>A module is a Java library that contains some code. What makes it a module is a
            special Java class that implements <link
                xlink:href="https://google.github.io/guice/api-docs/latest/javadoc/index.html?com/google/inject/Module.html"
                >Guice Module interface</link>. This class defines what "services" or other types of
            objects the module provides (in other words what will be injectable by the module
            users). This is done in a form of "bindings", i.e. associations between publicly visible
            injectable service interfaces and specific
            implementations:<programlisting language="java">public class MyModule implements Module {
	@Override
	public void configure(Binder binder) {
		binder.bind(MyService.class).to(MyServiceImpl.class);
	}
}</programlisting></para>
            <para>There are other flavors of bindings in Guice. Please refer to <link
                xlink:href="https://github.com/google/guice/wiki/Motivation">Guice
                documentation</link> for details. One important form extensively used in Bootique is
                <link xlink:href="https://github.com/google/guice/wiki/Multibindings"
                >Multibinding</link>.</para>
        
    </chapter>
    <chapter xml:id="programming-module-providers">
            <title>Modules Auto-Loading</title>
            <para>Modules can be automatically loaded via <code>Bootique.autoLoadModules()</code> as
            long as they are included in your aplication dependencies. Auto-loading depends on the
            Java <link
                xlink:href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html"
                >ServiceLoader mechanism</link>. To ensure your modules can be auto-loaded do two
            things. First implement <code>com.nhl.bootique.BQModuleProvider</code> interface
            specific to your
            module:<programlisting language="java">public class MyModuleProvider implements BQModuleProvider {
	@Override
	public Module module() {
		return new MyModule();
	}
}</programlisting>After
            then create a file <code>META-INF/services/com.nhl.bootique.BQModuleProvider</code> with
            the only line being the name of your BQModuleProvider implementor. E.g.:</para>
            <programlisting>com.foo.MyModuleProvider</programlisting>
            <para><code>BQModuleProvider</code> has two more methods that you can optionally
            implement to help Bootique to make sense of the module being
            loaded:<programlisting language="java">public class MyModuleProvider implements BQModuleProvider {
	...
	// provides human-readable name of the module
	@Override
	public String name() {
		return "CustomName";
	}
	
	// a collection of modules whose services are overridden by this module
	@Override
	public Collection&lt;Class&lt;? extends Module>> overrides() {
		return Collections.singleton(BQCoreModule.class);
	}
}</programlisting></para>
        <para>If  in your Module you are planning to redefine any services from the upstream
            modules, specify those upstream modules in the <code>overrides()</code> collection. </para>
    </chapter>
    <chapter xml:id="programming-configuration">
            <title>Reading Configuration and Configurable Factories</title>
        <para>As mentioned above, a Bootique app can be started with a YAML configuration file. Here
            is a simple example of such
            file:<programlisting language="python">log:
  level: warn
  appenders:
    - type: file
      logFormat: '%c{20}: %m%n'
      file: target/logback/debug.log

jetty:
  context: /myapp
  connector:
    port: 12009
</programlisting></para>
        <para>While this is not strictly required, as a rule the top-level keys in the file belong
            to configuration objects of individual modules. In the example above "log" subtree
            configures <code>bootique-logback</code> module, while "jetty" subtree configures
                <code>bootique-jetty-module</code>. For standard modules, refer to module-specific
            documentation on the structure of the supported configuration. Here we'll discuss how to
            build your own configuration-aware module.</para>
        <para>Bootique allows the Module to read its specific configuration subree as an object of
            the type defined in the Module. Very often such an object as written as a factory that
            contains a bunch of setters for the configuration properties, and a factory method to
            produce some service that a Module is interested in based on this configuration. Here is
            an example
            factory:<programlisting language="java">public class MyFactory {

	private int intProperty;
	private String stringProperty;

	public void setIntProperty(int i) {
		this.intProperty = i;
	}

	public void setStringProperty(String s) {
		this.stringProperty = s;
	}

	// factory method
	public MyService createMyService(SomeOtherService soService) {
		return new MyServiceImpl(soService, intProperty, stringProperty);
	}
}</programlisting></para>
        <para>The factory contains configuration property declarations, as well as public setters
            for these properties (you can create the getters if you want as well. While this is not
            strictly required, it may be useful. E.g. for unit tests). Now let's take a look at the
            Module
            class:<programlisting language="java">public class MyModule extends ConfigModule {
	@Provides
	public MyService createMyService(
             ConfigurationFactory configFactory, 
             SomeOtherService soService) {

		return configFactory
                 .config(MyFactory.class, configPrefix)
                 .createMySerice(soService);
	}
}</programlisting></para>
        <para>And now a sample configuration that will work with our
            module:<programlisting>my:
  intProperty: 55
  stringProperty: 'Hello, world!'</programlisting></para>
        <para>A few points to note here: </para>
        <para>
            <itemizedlist>
                <listitem>
                    <para>Calling our module "MyModule" and extending from <code>ConfigModule</code>
                        gives it access to the protected "configPrefix" instance variable that is
                        initialized to the value of "my" (the naming convention here is to use the
                        Module simple class name without the "Module" suffix and converted to
                        lowercase).</para>
                </listitem>
                <listitem>
                    <para><code>@Provides</code> annotation is a Guice way of marking a Module
                        method as a "provider" for a certain type of injectable service. All its
                        parameters are themselves injectable objects. </para>
                </listitem>
                <listitem>
                    <para><code>ConfigurationFactory</code> is the class used to bind a subtree in
                        the app YAML configuration to a given Java object (in our case - MyFactory).
                        The structure of MyFactory is very simple here, but can be as complex as
                        needed, containing nested objects, arrays, maps, etc. Internally Bootique
                        uses <link xlink:href="http://wiki.fasterxml.com/JacksonHome">Jackson
                            framework</link> to bind YAML to a Java class, so all the features of
                        Jackson can be used to craft configuration.</para>
                </listitem>
            </itemizedlist>
        </para>
        <section>
            <title>Polymorphic Configuration Objects</title>
            <para>A powerful feature of Jackson is the ability to dynamically create subclasses of
                the configuration objects. Bootique takes full advantage of this. E.g. imagine a
                logging module that needs "appenders" to output its log messages (file appender,
                console appender, syslog appender, etc.). The framework might not be aware of all
                possible appenders its users might come up with in the future. Yet it still wants to
                have the ability to instantiate any of them, based solely on the data coming from
                YAML. Moreover each appender will have its own set of incompatble configuration
                properties. In fact this is exactly the situation with <code>bootique-logback</code>
                module. </para>
            <para>Here is how you ensure that such a polimorphic configuration is possible. Let's
                start with a simple class hierarchy and a factory that contains a variable of the
                supertype that we'd like to init to a concrete subclass in
                runtime:<programlisting language="java">public abstract class SuperType {
...
}

public class ConcreteType1 extends SuperType {
...
}

public class ConcreteType2 extends SuperType {
...	
}

public class MyFactory {

	// can be a class or an interface
	private SuperType subconfig;
	

	public void setSubconfig(SuperType s) {
		this.subconfig = s;
	}	
...
}</programlisting></para>
            <para>To make polimorphism work, we need to provide some instructions to Jackson. First
                we need to annotate the supertype and
                subtypes:<programlisting language="java">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, 
     property = "type", 
     defaultImpl = ConcreteType1.class)
public abstract class SuperType {

}

@JsonTypeName("type1")
public class ConcreteType1 extends SuperType {

}

@JsonTypeName("type2")
public class ConcreteType2 extends SuperType {
	
}</programlisting></para>
            <para>After that we need to create a service provider file called
                    <code>META-INF/service/com.nhl.bootique.config.PolymorphicConfiguration</code>
                where all the types participating in the hierarchy are listed (including the
                supertype):<programlisting>com.foo.SuperType
com.foo.ConcreteType1
com.foo.ConcreteType2</programlisting></para>
            <para>This should be enough to work with configuration like
                this:<programlisting>my:
  subconfig:
    type: type2
    someVar: someVal</programlisting></para>
            <para>Or this (here type is implicitly assumed to be "type1", see the "defaultImpl" in
                the <code>@JsonTypeInfo</code> annotation
                above:<programlisting>my:
  subconfig:
    someOtherVar: someOtherVal</programlisting></para>
            <para>If another module decides to create yet another subclass of SuperType, it will
                need to create its own
                    <code>META-INF/service/com.nhl.bootique.config.PolymorphicConfiguration</code>
                file that metions the new subclass.</para>
        </section>
    </chapter>
    <chapter xml:id="programming-using-modules">
            <title>Using Modules</title>
            <para>Modules can use other "upstream" modules in a few ways:<itemizedlist>
                <listitem>
                    <para>"Import": a downstream module uses another module as a library, ignoring
                        its injectable services.</para>
                </listitem>
                <listitem>
                    <para>"Use" : downstream module's classes inject classes from an upstream
                        module.</para>
                </listitem>
                <listitem>
                    <para>"Contribute": downstream module injects objects to collections and maps
                        defined in upstream modules.</para>
                </listitem>
            </itemizedlist></para>
            <para>Import case is trivial, so we'll concentrate on the two remaining scenarios. We
            will use <link
                xlink:href="https://github.com/nhl/bootique/blob/master/bootique/src/main/java/com/nhl/bootique/BQCoreModule.java"
                >BQCoreModule</link> as an example of an upstream module, as it is available in all
            apps.</para>
        <section>
            <title>Injecting Other Module's Services</title>
            <para>BQCoreModule provides a number of objects and services that can be accessed via
                injection and used by your code.
                E.g.:<programlisting language="java">class MyService {

	@Args
	@Inject
	private String[] args;

	public String getArgsString() {
		return Arrays.asList(getArgs()).stream().collect(joining(" "));
	}
}</programlisting></para>
            <para>In this example we injected command line arguments that were used to start the
                app. Note that since there can potentially be more than one <code>String[]</code> in
                a DI container, Bootique <code>@Args</code> annotation is used to uniquely identify
                the array that we want here.</para>
        </section>
        <section>
            <title>Contributing to Other Modules</title>
            <para>Guice supports <link
                    xlink:href="https://github.com/google/guice/wiki/Multibindings"
                    >multibindings</link>, intended to <emphasis>contribute</emphasis> objects
                defined in a downstream module to collections/maps used by services in upstream
                modules. E.g. the following code makes <code>MyCommand</code> available in the app
                set of
                commands:<programlisting>public class MyModule implements Module {

	@Override
	public void configure(Binder binder) {
		BQCoreModule.contributeCommands(binder)
			.addBinding()
			.to(MyCommand.class);
	}
}</programlisting></para>
            <para>Here we obtained a Multibinder instance via a static method on BQCoreModule. Most
                standard modules define such helper methods for every collection/map that should be
                populated by module users. This is a pattern you might want to follow in your own modules.<note>
                    <para>Commands can be alternatively contributed using a special
                            <code>Commands</code> module builder described below, which is a
                        shortcut for the code above.</para>
                </note></para>
        </section>
        </chapter>
    <chapter xml:id="programming-application-module">
            <title>Application as a Module</title>
            <para>The class that contains the <code>"main()"</code> method is informally called
                "application". Bootique does not impose any particular requirements on this class.
                You decide what to put in it. It can be limited to just <code>"main()"</code>,
                turned into a REST resource, etc. </para>
            <para>We recommend wrapping all your custom code in Guice modules. Then you can view
            your apps as collections of modules. In this scenario, it makes the most sense to write
            your application class as either just a launcher with the static <code>"main()"</code>
            method or in addition to that turn it into a Module as well. After all Bootique app is
            just a collection of Modules, and it is but logical that your Application represents
            that one final Module to rule them
            all:<programlisting>public class Application implements Module {

   public static void main(String[] args) {
      Bootique.app(args).module(Application.class).autoLoadModules().run();
   }

   public void configure(Binder binder) {
      // load app-specific services; redefine standard ones
   }
}</programlisting></para>
            <para>You may also implement a separate BQModuleProvider for the Application module.
            Then <code>autoLoadModules()</code> will discover it just like any other Module, and
            there won't be a need to add Application module explicitly.</para>
    </chapter>
        
    <chapter>
        <title>Commands and Options</title>
        <para>Bootique runtime contains a set of commands. Bootique derives a command name to
            execute from the command line arguments. The initial set of available commands is a
            combination of commands coming from Bootique core framework and any modules currently in
            effect in the app.</para>
        <para>TODO</para>
        
    </chapter>
 
    <chapter>
        <title>Logging</title>
        <para>TODO</para>
    </chapter>
</part>
